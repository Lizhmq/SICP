#lang racket
(require r5rs)
(define (front-ptr queue) (car queue))
(define (rear-ptr queue) (cdr queue))
(define (set-front-ptr! queue item) (set-car! queue item))
(define (set-rear-ptr! queue item) (set-cdr! queue item))
(define (make-queue) (cons '() '()))
(define (clear q) (set! q (make-queue)))
(define (front-queue queue)
  (car (front-ptr queue)))
(define (empty-queue? queue) (null? (car queue)))
(define (insert-queue! queue item)
  (let ((new-pair (cons item '())))
    (cond ((empty-queue? queue)
           (set-front-ptr! queue new-pair)
           (set-rear-ptr! queue new-pair)
           queue)
          (else
           (set-cdr! (rear-ptr queue) new-pair)
           (set-rear-ptr! queue new-pair)
           queue))))
(define (delete-queue! queue)
  (set-front-ptr! queue (cdr (front-ptr queue))))

(define (make-table) '())
(define (maketable m n)
  (cons (cons m n) (make-vector (* m n) -1)))
(define makelist2 maketable)
(define (lookup2 key1 key2 table)
  (vector-ref (cdr table)  (+ key2 (* key1 (cdar table)))))
(define (set key1 key2 table value)
  (vector-set! (cdr table) (+ key2 (* key1 (cdar table))) value))
(define (show a)
  (if a
      (displayln a)
      (displayln 'inf)))
(define mytable '())
(define table '())
(define (solve)
  (define (check x y K m n)
    (cond ((< x 0) #f)
          ((>= x m) #f)
          ((< y 0) #f)
          ((>= y n) #f)
          (else
           (and
            (> K (lookup2 x y mytable))
            (not (equal? 'W (lookup2 x y table)))))))
  (define (BFS m n)
    (if (empty-queue? q)
        #f
        (let* ((front (front-queue q))
               (x (car front))
               (y (cadr front))
               (K (caddr front))
               (step (cadddr front)))
          (cond ((and (= x (- m 1)) (= y (- n 1)) (>= K 0)) step)
                ((and (= x (- m 1)) (= y (- n 1)))
                 (begin (delete-queue! q)
                        (BFS m n)))
                ((check x y K m n)
                 (set x y mytable K)
                 (let* ((p (eq? (lookup2 x y table) 'M))
                        (delta (if p 1 0)))
                   (insert-queue! q (list (+ x 1) y (- K delta) (+ step 1)))
                   (insert-queue! q (list (- x 1) y (- K delta) (+ step 1)))
                   (insert-queue! q (list x (+ y 1) (- K delta) (+ step 1)))
                   (insert-queue! q (list x (- y 1) (- K delta) (+ step 1)))
                   (delete-queue! q)
                   (BFS m n)))
                (else
                 (begin (delete-queue! q)
                        (BFS m n)))))))  
  (let* ((m (read))
         (n (read))
         (k (read)))
    (begin (set! table (makelist2 m n))
           (set! mytable (maketable m n))
           (for* ((i (range m))
                 (j (range n)))
             (set i j table (read)))
             
           (set! q (make-queue))
           (insert-queue! q (list 0 0 k 0))
           (show (BFS m n)))))

(define t (read))
(define q (make-queue))
(define (main)
  (if (= t 0)
      (void)
      (begin
        (clear q)
        (solve)
        (set! t (- t 1))
        (main))))
(main)