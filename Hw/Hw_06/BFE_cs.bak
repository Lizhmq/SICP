#lang racket
(require r5rs)
(require data/queue)
(define (make-2D x y c)
  (cons (list x y) (make-vector (* x y) c)
(define (2D-ref array x y)
  (vector-ref (cdr array) (+ y (* x (cadr (car array)
(define (2D-set! array x y v)
  (vector-set! (cdr array) (+ y (* x (cadr (car array) v)
(define (make-3D x y z c)
  (cons (list x y z) (make-vector (* x y z) c)
(define (3D-ref array x y z)
  (vector-ref (cdr array) (+ z (* y (caddr (car array) (* x (caddr (car array) (cadr (car array)
(define (3D-set! array x y z v)
  (vector-set! (cdr array) (+ z (* y (caddr (car array) (* x (caddr (car array) (cadr (car array) v)

(define (solve M N K)
  (define S (make-2D M N 0)
  (define Q (make-queue)
  (for* (i (range M)
         (j (range N)
    (2D-set! S i j (read)
  ;(displayln S)
  (define Sea (make-3D M N (+ K 1) -1)
  (3D-set! Sea 0 0 0 0)
  (enqueue! Q (list 0 0 0)
  (define (doit)
    (if (queue-empty? Q)
        'inf
        (begin  (let* (E (dequeue! Q)
                       (x (car E)
                       (y (cadr E)
                       (z (caddr E)
                       (step (3D-ref Sea x y z)
                  (if (and (= x (- M 1) (= y (- N 1)
                      step
                      (begin (if (and (> x 0) (not (eq? 'W (2D-ref S (- x 1) y)
                                 (expand (- x 1) y z step)
                                 (void)
                             (if (and (< x (- M 1) (not (eq? 'W (2D-ref S (+ x 1) y)
                                 (expand (+ x 1) y z step)
                                 (void)
                             (if (and (> y 0) (not (eq? 'W (2D-ref S x (- y 1)
                                 (expand x (- y 1) z step)
                                 (void)
                             (if (and (< y (- N 1) (not (eq? 'W (2D-ref S x (+ y 1)
                                 (expand x (+ y 1) z step)
                                 (void)
                             (doit)
  (define (expand x y z s)
    (let (A (2D-ref S x y)
      (if (eq? A 'B) 
          (if (< (3D-ref Sea x y z) 0)
              (begin (enqueue! Q (list x y z)
                     ;(displayln (list x y z)
                     (3D-set! Sea x y z (+ s 1)
              (void)
          (if (and (< z K) (< (3D-ref Sea x y (+ z 1) 0)
              (begin (enqueue! Q (list x y (+ z 1)
                     ;(displayln (list x y (+ z 1)
                     (3D-set! Sea x y (+ z 1) (+ s 1)
              (void)
  (doit)
(define (main)
  (let (case (read)
    (for (i (range case)
      (displayln (solve (read) (read) (read)
(main)