#lang racket

(define (enumerate-interval a b)
  (if (> a b)
      '()
      (cons a (enumerate-interval (+ a 1) b))))
(define (last lst)
  (if (null? (cdr lst))
      (car lst)
      (last (cdr lst))))
(define (safe? k positions)
  (if (= k 1)
      #t
      (let ((a (car positions)) (b (last positions)))
        (and 
         (not (= a b))
         (not (= (- a b) (- k 1)))
         (not (= (- b a) (- k 1)))
         (safe? (- k 1) (cdr positions))))))
(define (flatmap op lst)
  (if (null? lst)
      '()
      (append (op (car lst)) (flatmap op (cdr lst)))))
(define (adjoin-position new-row k rest)
  (append rest (list new-row)))
(define (queens board-size)
  (define (queen-cols k)
    (if (= k 0)
        (list '())
        (filter
         (lambda (positions) (safe? k positions))
         (flatmap
          (lambda (rest-of-queens)
            (map (lambda (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))
(define a (queens 8))
(define k (read))
(define (show lst)
  (if (null? lst)
      (void)
      (begin (display (car lst)) (show (cdr lst)))))
(define (solve k x)
  (if (= k 1)
      (show (car x))
      (solve (- k 1) (cdr x))))
(define (main)
  (define r (read))
  (if (eq? r eof)
      (void)
      (begin (solve r a) (newline) (main))))
(main)