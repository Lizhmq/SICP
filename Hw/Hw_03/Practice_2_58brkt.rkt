#lang racket
(define (variable? exp)
  (if (pair? exp)
      (and (= (length exp) 1) (symbol? (car exp)))
      (symbol? exp)))
(define (same-variable? exp var)
  (and (variable? exp) (variable? var) (eq? (if (pair? exp) (car exp) exp) var)))
(define (sum? exp)
  (if (null? exp)
      #f
      (and (pair? exp) (or (eq? (car exp) '+) (sum? (cdr exp))))))
(define (=number? a b)
  (and (number? a) (= a b)))
(define (make-sum a b)
  (cond ((=number? a 0) b)
        ((=number? b 0) a)
        ((and (number? a) (number? b)) (+ a b))
        ((or (and (isum? a) (isum? b)) (and (iproduct? a) (iproduct? b))) (mappend a (list '+) b))
        (else (list a '+ b))))
(define (simple a)
  (if (and (pair? a) (= (length a) 1))
      (car a)
      a))
(define (addend exp)
  (define (maddend exp) (if (eq? (car exp) '+)
              '()
              (cons (car exp) (maddend (cdr exp)))))
  (simple (maddend exp)))
(define (augend exp)
  (define (maugend exp) (if (eq? '+ (car exp))
              (cdr exp)
              (maugend (cdr exp))))
  (simple (maugend exp)))
(define (product? exp)
  (if (null? exp)
              #f
              (and (pair? exp) (or (eq? (car exp) '*) (product? (cdr exp))))))
(define (multiplier exp)
  (define (mmultiplier exp) (if (eq? (car exp) '*)
              '()
              (cons (car exp) (mmultiplier (cdr exp)))))
  (simple (mmultiplier exp)))
(define (multiplicand exp)
  (define (mmultiplicand exp) (if (eq? '* (car exp))
      (cdr exp)
      (mmultiplicand (cdr exp))))
  (simple (mmultiplicand exp)))
(define (isum? exp)
  (or (sum? exp) (symbol? exp)))
(define (iproduct? exp)
  (and (not (sum? exp)) (or (product? exp) (symbol? exp))))
(define (make-product a b)
  (cond ((or (=number? a 0) (=number? b 0)) 0)
        ((=number? a 1) b)
        ((=number? b 1) a)
        ((and (number? a) (number? b)) (* a b))
        ((and (iproduct? a) (iproduct? b)) (mappend a (list '*) b))
        (else (list a '* b))))
(define (mappend a b c)
  (let ((aa (if (list? a) a (list a))) (cc (if (list? c) c (list c))))
    (append aa b cc)))
(define (deriv exp var)
  (cond ((number? exp ) 0)
        ((variable? exp)
         (if (same-variable? exp var) 1 0))
        ((sum? exp)
         (make-sum (deriv (addend exp) var)
                   (deriv (augend exp) var)))
        ((product? exp)
         (make-sum 
          (make-product (multiplier exp)
                        (deriv (multiplicand exp) var))
          (make-product (deriv (multiplier exp) var)
                        (multiplicand exp))))
        (else 
         (error "wrong format"))))

(define (myloop)
  (let ((a (read)))
    (if (eq? a eof)
        (void)
        (begin (display (deriv a 'x)) (newline) (myloop)))))

(myloop)