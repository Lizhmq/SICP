#lang racket

(require r5rs)
(require data/queue)

(define (show res)
  (if res
      (displayln res)
      (displayln "inf")))
(define m 0)
(define n 0)
(define k 0)
(define mem '())
(define map '())
(define q '())
(define (make-mem m n)
  (define (make-mem-list m n)
    (if (= m 0)
        '()
        (cons (make-vector n -1) (make-mem-list (- m 1) n))))
  (set! mem (list->vector (make-mem-list m n))))
(define (ref vec m n)
  (vector-ref (vector-ref vec m) n))
(define (set-vec vec m n val)
  (vector-set! (vector-ref vec m) n val))
(define (read-list n)
  (if (= n 0)
      '()
      (cons (read) (read-list (- n 1)))))
(define (make-map m n)
  (define (make-map-list m n)
    (if (= m 0)
        '()
        (cons (list->vector (read-list n)) (make-map-list (- m 1) n))))
  (set! map (list->vector (make-map-list m n))))
(define (make-q k)
  (set! q (make-queue))
  (enqueue! q (list 0 0 k 0)))
(define (solve)
  (set! m (read))
  (set! n (read))
  (set! k (read))
  (make-mem m n)
  (make-map m n)
  (make-q k)
  (show (BFS)))
(define (BFS)
  (if (queue-empty? q)
      #f
      (let* ((cur (dequeue! q))
             (x (car cur))
             (y (cadr cur))
             (k (caddr cur))
             (steps (cadddr cur)))
        (cond ((>= x m) (BFS))
              ((>= y n) (BFS))
              ((< x 0) (BFS))
              ((< y 0) (BFS))
              ((and (= x (- m 1))
                    (= y (- n 1)))
               steps)
              ((>= (ref mem x y) k) (BFS))
              ((eq? (ref map x y) 'W) (BFS))
              (else
               (set-vec mem x y k)
               (let* ((delta (if (eq? (ref map x y) 'M) 1 0))
                      (k (- k delta))
                      (steps (+ steps 1)))
                 (enqueue! q (list (+ x 1) y k steps))
                 (enqueue! q (list (- x 1) y k steps))
                 (enqueue! q (list x (+ y 1) k steps))
                 (enqueue! q (list x (- y 1) k steps))
                 (BFS)))))))
                 
                 
(define (main)
  (define (loop n)
    (if (= n 0)
        (void)
        (begin (solve) (loop (- n 1)))))
  (loop (read)))
(main)