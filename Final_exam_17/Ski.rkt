#lang racket

(require r5rs)

(define m 0)
(define n 0)
(define mem '())
(define mmap '())
(define (make-mem m n)
  (define (make-mem-list m n)
    (if (= m 0)
        '()
        (cons (make-vector n -1) (make-mem-list (- m 1) n))))
  (set! mem (list->vector (make-mem-list m n))))
(define (ref vec m n)
  (vector-ref (vector-ref vec m) n))
(define (set-vec vec m n val)
  (vector-set! (vector-ref vec m) n val))
(define (read-list n)
  (if (= n 0)
      '()
      (cons (read) (read-list (- n 1)))))
(define (make-mmap m n)
  (define (make-mmap-list m n)
    (if (= m 0)
        '()
        (cons (list->vector (read-list n)) (make-mmap-list (- m 1) n))))
  (set! mmap (list->vector (make-mmap-list m n))))
(define (solve)
  (define (solve-x-y x y)
    (DFS x y 10001))
  (define (solve-x x y)
    (if (>= y n)
        0
        (max (solve-x-y x y) (solve-x x (+ y 1)))))
  (define (solves x)
    (if (>= x m)
        0
        (max (solve-x x 0) (solves (+ x 1)))))
  (set! m (read))
  (set! n (read))
  (make-mem m n)
  (make-mmap m n)
  (displayln (solves 0)))
(define (DFS x y t)
  (cond ((>= x m) 0)
        ((>= y n) 0)
        ((< x 0) 0)
        ((< y 0) 0)
        ((> (ref mem x y) -1) (ref mem x y))
        ((<= t (ref mmap x y)) 0)
        (else
         (set-vec mem x y 0)
         (let ((a (DFS (+ x 1) y (ref mmap x y)))
               (b (DFS (- x 1) y (ref mmap x y)))
               (c (DFS x (+ y 1) (ref mmap x y)))
               (d (DFS x (- y 1) (ref mmap x y))))
           (let ((mm (+ (max a b c d) 1)))
             (set-vec mem x y mm)
             mm)))))
               
                 
(define (main)
  (define (loop n)
    (if (= n 0)
        (void)
        (begin (solve) (loop (- n 1)))))
  (loop 1))
(main)